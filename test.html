<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>iOS-style collapsing title</title>
    <style>
      :root {
        --header-height: 56px;
        --large-title-size: 34px;
        --small-title-size: 18px;
        --gap: 12px;
        --bg: #fff;
        --fg: #111;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial;
      }

      /* 상단 고정 헤더(작아지는 네비) */
      .topbar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: var(--header-height);
        display: flex;
        align-items: center;
        padding: 0 16px;
        border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.9),
          rgba(255, 255, 255, 0.75)
        );
        backdrop-filter: blur(6px);
        z-index: 40;
        transition: box-shadow 0.2s ease;
      }
      .topbar.scrolled {
        box-shadow: 0 1px 6px rgba(16, 24, 40, 0.06);
      }

      /* 큰 제목(스크롤 영역 안에 존재) */
      .hero {
        /* hero 영역은 상단을 덮는 큰 영역(예: 상세 페이지의 헤더) */
        padding: 96px 16px 20px;
        padding-top: calc(var(--header-height) + 20px);
        background: linear-gradient(180deg, #ffffff 0%, #fbfaf8 100%);
      }

      .large-title {
        font-size: var(--large-title-size);
        font-weight: 700;
        line-height: 1;
        margin: 0;
        transform-origin: left center;
        transition: transform 0.18s ease, opacity 0.18s ease;
        will-change: transform, opacity;
      }

      /* 네비에 들어갈 작은 타이틀(초기에는 보이지 않음) */
      .topbar .small-title {
        font-size: var(--small-title-size);
        font-weight: 600;
        opacity: 0;
        transform: translateY(6px);
        transition: opacity 0.18s ease, transform 0.18s ease;
        will-change: opacity, transform;
      }
      .topbar.scrolled .small-title {
        opacity: 1;
        transform: translateY(0);
      }

      /* 스크롤되면 large-title을 축소/숨김 처리할 때의 스타일 변경 (JS로 class 토글) */
      .hero.collapsed .large-title {
        transform: scale(0.52) translateY(-6px);
        opacity: 0;
      }

      /* 콘텐츠 영역 */
      .content {
        padding: 16px;
        padding-top: 8px;
        line-height: 1.6;
      }

      /* 접근성: motion 줄이기 */
      @media (prefers-reduced-motion: reduce) {
        .large-title,
        .topbar .small-title,
        .topbar {
          transition: none;
        }
      }

      /* 간단한 데모 높이 */
      .spacer {
        height: 1200px;
      }
    </style>
  </head>
  <body>
    <header class="topbar" id="topbar">
      <div style="display: flex; align-items: center; gap: 12px; width: 100%">
        <!-- 왼쪽 버튼 예시 -->
        <button
          aria-label="뒤로"
          style="border: 0; background: none; padding: 8px; border-radius: 8px"
        >
          ◀
        </button>

        <!-- 스크롤 시 보일 작은 타이틀 -->
        <div class="small-title">프로필</div>

        <!-- 우측에 action -->
        <div style="margin-left: auto">
          <button
            aria-label="설정"
            style="
              border: 0;
              background: none;
              padding: 8px;
              border-radius: 8px;
            "
          >
            ⚙
          </button>
        </div>
      </div>
    </header>

    <!-- 큰 타이틀을 포함한 hero 영역 (스크롤 타겟) -->
    <section class="hero" id="hero">
      <h1 class="large-title">프로필</h1>
      <p style="margin-top: 10px; color: #666">
        간단한 설명이나 서브타이틀을 여기에 넣을 수 있습니다.
      </p>
    </section>

    <main class="content">
      <div class="spacer">
        <!-- 충분히 길어야 스크롤 효과를 확인 가능 -->
        본문 내용...
      </div>
    </main>

    <script>
      // IntersectionObserver로 hero 영역의 바닥에 닿는 시점(또는 헤더와 겹치는 시점)을 잡아 클래스 토글
      (function () {
        const hero = document.getElementById("hero");
        const topbar = document.getElementById("topbar");

        // 관찰할 dummy sentinel을 hero 바로 아래에 만든다
        const sentinel = document.createElement("div");
        sentinel.style.position = "absolute";
        sentinel.style.top = hero.offsetTop + hero.offsetHeight - 1 + "px";
        sentinel.style.width = "1px";
        sentinel.style.height = "1px";
        // we append to body to observe viewport intersection
        document.body.appendChild(sentinel);

        let io = new IntersectionObserver(
          (entries) => {
            for (const entry of entries) {
              // entry.isIntersecting === true 이면 sentinel이 뷰포트에 보이는 상태
              // 여기서는 sentinel이 보이면 hero가 아직 충분히 보여지므로 collapsed 해제
              if (entry.isIntersecting) {
                hero.classList.remove("collapsed");
                topbar.classList.remove("scrolled");
              } else {
                hero.classList.add("collapsed");
                topbar.classList.add("scrolled");
              }
            }
          },
          { threshold: [0, 1] }
        );

        io.observe(sentinel);

        // 리사이즈 시 sentinel 위치 재계산 (안정성)
        window.addEventListener("resize", () => {
          sentinel.style.top = hero.offsetTop + hero.offsetHeight - 1 + "px";
        });
      })();
    </script>
  </body>
</html>
